// Generated by CoffeeScript 1.8.0
(function() {
  var ByteBuffer, assert, async, blanket, config;

  assert = require('chai').assert;

  async = require('async');

  ByteBuffer = require('../node_modules/protobufjs/node_modules/bytebuffer');

  config = require('./test_config');

  blanket = (require('blanket'))();

  describe('hbase', function() {
    var client, deleteRow, getRow, hbase, putRow, randomValue, rowDoesNotExist, tCf, tCol, tRow, tVal, testRows, testTable;
    before(function(done) {
      var rows;
      rows = testRows.map(function(row) {
        return row.row;
      });
      return client.mdelete(testTable, rows, function() {
        var matchesBlanket, runningTestCoverage;
        matchesBlanket = function(path) {
          return path.match(/node_modules\/blanket/);
        };
        runningTestCoverage = Object.keys(require.cache).filter(matchesBlanket).length > 0;
        if (runningTestCoverage) {
          require('require-dir')("" + __dirname + "/../lib", {
            recurse: true,
            duplicates: true
          });
        }
        return done();
      });
    });
    this._timeout = config.timeout;
    testTable = config.testTable;
    testRows = [
      {
        row: '1',
        cf: 'cf1',
        col: 'col1',
        val: 'val1'
      }, {
        row: '5',
        cf: 'cf1',
        col: 'col2',
        val: 'val2'
      }, {
        row: '9',
        cf: 'cf1',
        col: 'col3',
        val: 'val3'
      }, {
        row: 'a',
        cf: 'cf1',
        col: 'col4',
        val: 'val4'
      }
    ];
    tCf = testRows[0].cf;
    tRow = testRows[0].row;
    tCol = testRows[0].col;
    tVal = testRows[0].val;
    randomValue = 'lkjhgfdsa';
    hbase = require('../index.coffee');
    client = hbase({
      zookeeperHosts: config.zookeeperHosts,
      zookeeperRoot: config.zookeeperRoot
    });
    putRow = function(row, cf, col, val, ts, cb) {
      var put;
      if (typeof ts === 'function') {
        cb = ts;
        ts = null;
      }
      put = new hbase.Put(row);
      put.add(cf, col, val, ts);
      return client.put(testTable, put, function(err, res) {
        assert.notOk(err, "put returned an error: " + err);
        assert.equal(res.processed, true, "put wasn't processed");
        return getRow(row, cf, col, val, ts, cb);
      });
    };
    getRow = function(row, cf, col, val, ts, cb) {
      var get;
      if (typeof ts === 'function') {
        cb = ts;
        ts = null;
      }
      get = new hbase.Get(row);
      get.addColumn(cf, col);
      return client.get(testTable, get, function(err, res) {
        assert.notOk(err, "get returned an error: " + err);
        assert.equal(res.row, row, "rowKey doesn't match");
        assert.equal(res.columns[0].family.toString(), cf, "columnFamily doesn't match");
        assert.equal(res.columns[0].qualifier.toString(), col, "qualifier doesn't match");
        if (ts) {
          assert.equal(res.columns[0].timestamp.toString(), ts.toString(), "timestamp doesn't match");
        }
        if (typeof val === 'object') {
          assert.equal(res.columns[0].value.toString(), val.toString(), "value doesn't match");
        } else {
          assert.equal(res.columns[0].value, val, "value doesn't match");
        }
        return cb(null, res);
      });
    };
    deleteRow = function(row, cb) {
      var del;
      del = new hbase.Delete(row);
      return client["delete"](testTable, del, function(err, res) {
        assert.notOk(err, "delete returned an error: " + err);
        assert.equal(res.processed, true, "delete wasn't processed");
        return rowDoesNotExist(row, cb);
      });
    };
    rowDoesNotExist = function(row, cb) {
      var get;
      get = new hbase.Get(row);
      return client.get(testTable, get, function(err, res) {
        assert.notOk(err, "get returned an error: " + err);
        assert.notOk(res, "row " + row + " exists");
        return cb();
      });
    };
    describe('put & mput', function() {
      afterEach(function(done) {
        var rows;
        rows = testRows.map(function(row) {
          return row.row;
        });
        return client.mdelete(testTable, rows, done);
      });
      it('should put single row', function(done) {
        return putRow(tRow, tCf, tCol, tVal, done);
      });
      it('should put multiple rows via simple array', function(done) {
        var puts;
        puts = [];
        puts = testRows.map(function(row) {
          var o;
          o = {
            row: row.row
          };
          o["" + row.cf + ":" + row.col] = row.val;
          return o;
        });
        return client.mput(testTable, puts, function(err, res) {
          assert.notOk(err, "mput returned an error: " + err);
          return done();
        });
      });
      it('should put multiple rows via array of Put objects', function(done) {
        var puts;
        puts = testRows.map(function(row) {
          var put;
          put = new hbase.Put(row.row);
          put.add(row.cf, row.col, row.val);
          return put;
        });
        return client.mput(testTable, puts, function(err, res) {
          assert.notOk(err, "mput returned an error: " + err);
          return done();
        });
      });
      return it('should checkAndPut', function(done) {
        return putRow(tRow, tCf, tCol, tVal, function() {
          var put;
          put = new hbase.Put(tRow);
          put.add(tCf, tCol, randomValue);
          return client.checkAndPut(testTable, tRow, tCf, tCol, tVal, put, function(err, res) {
            assert.notOk(err, "checkAndPut returned an error: " + err);
            assert.equal(res.processed, true, "checkAndPut wasn't processed");
            return getRow(tRow, tCf, tCol, randomValue, done);
          });
        });
      });
    });
    describe('get & mget', function() {
      before(function(done) {
        var puts;
        puts = testRows.map(function(row) {
          var put;
          put = new hbase.Put(row.row);
          put.add(row.cf, row.col, row.val);
          return put;
        });
        return client.mput(testTable, puts, done);
      });
      after(function(done) {
        var rows;
        rows = testRows.map(function(row) {
          return row.row;
        });
        return client.mdelete(testTable, rows, done);
      });
      it('should get single row', function(done) {
        return getRow(tRow, tCf, tCol, tVal, done);
      });
      it('should get single row with invalid maxVersions', function(done) {
        var get;
        get = new hbase.Get(tRow);
        get.setMaxVersions(0);
        return client.get(testTable, get, function(err, res) {
          assert.notOk(err, "get returned an error: " + err);
          assert.equal(res.row, tRow, "rowKey doesn't match");
          return done();
        });
      });
      it('should get multiple rows via simple array', function(done) {
        var gets;
        gets = testRows.map(function(row) {
          return row.row;
        });
        return client.mget(testTable, gets, function(err, res) {
          assert.notOk(err, "mget returned an error: " + err);
          assert.equal(res.length, testRows.length, "mget didn't return expected number of rows");
          return done();
        });
      });
      it('should get multiple rows via array of Get objects', function(done) {
        var gets;
        gets = testRows.map(function(row) {
          return new hbase.Get(row.row);
        });
        return client.mget(testTable, gets, function(err, res) {
          assert.notOk(err, "mget returned an error: " + err);
          assert.equal(res.length, testRows.length, "mget didn't return expected number of rows");
          return done();
        });
      });
      it('should get multiple versions', function(done) {
        var tests;
        tests = [
          function(cb) {
            return putRow(tRow, tCf, tCol, tVal, cb);
          }, function(r, cb) {
            return putRow(tRow, tCf, tCol, tVal + '1', cb);
          }, function(r, cb) {
            return putRow(tRow, tCf, tCol, tVal + '2', cb);
          }, function(r, cb) {
            var get;
            get = new hbase.Get(tRow);
            get.setMaxVersions(3);
            return client.get(testTable, get, function(err, row) {
              assert.notOk(err, "get returned an error: " + err);
              assert.equal(row.cols["" + tCf + ":" + tCol][0].value.toString(), tVal + '2', "latest version value doesn't match");
              assert.equal(row.cols["" + tCf + ":" + tCol][1].value.toString(), tVal + '1', "2nd latest version value doesn't match");
              assert.equal(row.cols["" + tCf + ":" + tCol][2].value.toString(), tVal, "oldest version value doesn't match");
              return cb();
            });
          }, function(cb) {
            var del;
            del = new hbase.Delete(tRow);
            del.deleteColumns(tCf, tCol);
            return client["delete"](testTable, del, function(err, res) {
              assert.notOk(err, "delete returned an error: " + err);
              assert.equal(res.processed, true, "delete wasn't processed");
              return cb();
            });
          }, function(cb) {
            return rowDoesNotExist(tRow, cb);
          }
        ];
        return async.waterfall(tests, done);
      });
      return it('should get with timeRange', function(done) {
        var tests, ts;
        ts = null;
        tests = [
          function(cb) {
            return putRow(tRow, tCf, tCol, tVal, function(err, row) {
              ts = row.cols["" + tCf + ":" + tCol].timestamp;
              return cb();
            });
          }, function(cb) {
            return putRow(tRow, tCf, tCol, tVal + '1', cb);
          }, function(r, cb) {
            var get, ts1, ts2;
            ts1 = ts2 = ts;
            ts1--;
            ts2++;
            get = new hbase.Get(tRow);
            get.setTimeRange(ts1, ts2);
            return client.get(testTable, get, function(err, row) {
              assert.notOk(err, "get returned an error: " + err);
              assert.equal(row.row, tRow, "rowKey doesn't match");
              assert.equal(row.cols["" + tCf + ":" + tCol].value, tVal, "value doesn't match");
              return cb();
            });
          }, function(cb) {
            return deleteRow(tRow, cb);
          }
        ];
        return async.waterfall(tests, done);
      });
    });
    describe('delete & mdelete', function() {
      beforeEach(function(done) {
        var puts;
        puts = testRows.map(function(row) {
          var put;
          put = new hbase.Put(row.row);
          put.add(row.cf, row.col, row.val);
          return put;
        });
        return client.mput(testTable, puts, done);
      });
      after(function(done) {
        var rows;
        rows = testRows.map(function(row) {
          return row.row;
        });
        return client.mdelete(testTable, rows, done);
      });
      it('should delete row', function(done) {
        return deleteRow(testRows[1].row, done);
      });
      it('should checkAndDelete row', function(done) {
        return putRow(tRow, tCf, tCol, randomValue, function() {
          var del;
          del = new hbase.Delete(tRow);
          return client.checkAndDelete(testTable, tRow, tCf, tCol, randomValue, del, function(err, res) {
            var get;
            assert.notOk(err, "checkAndDelete returned an error: " + err);
            assert.equal(res.processed, true, "checkAndDelete wasn't processed");
            get = new hbase.Get(tRow);
            return client.get(testTable, get, function(err, res) {
              assert.notOk(err, "get returned an error: " + err);
              assert.notOk(res, "row " + tRow + " exists");
              return done();
            });
          });
        });
      });
      it('should deleteColumn & deleteColumns', function(done) {
        var tests;
        tests = [
          function(cb) {
            return putRow(tRow, tCf, tCol, tVal, cb);
          }, function(r, cb) {
            return putRow(tRow, tCf, tCol, tVal + '1', cb);
          }, function(r, cb) {
            return putRow(tRow, tCf, tCol, tVal + '2', cb);
          }, function(r, cb) {
            var del;
            del = new hbase.Delete(tRow);
            del.deleteColumn(tCf, tCol);
            return client["delete"](testTable, del, function(err, res) {
              assert.notOk(err, "delete returned an error: " + err);
              assert.equal(res.processed, true, "delete wasn't processed");
              return cb();
            });
          }, function(cb) {
            return getRow(tRow, tCf, tCol, tVal + '1', cb);
          }, function(r, cb) {
            var del;
            del = new hbase.Delete(tRow);
            del.deleteColumns(tCf, tCol);
            return client["delete"](testTable, del, function(err, res) {
              assert.notOk(err, "delete returned an error: " + err);
              assert.equal(res.processed, true, "delete wasn't processed");
              return cb();
            });
          }, function(cb) {
            return rowDoesNotExist(tRow, cb);
          }
        ];
        return async.waterfall(tests, done);
      });
      it('should deleteFamily & deleteFamilies', function(done) {
        var tests, ts;
        ts = null;
        tests = [
          function(cb) {
            return putRow(tRow, tCf, tCol, tVal, function(err, row) {
              ts = row.cols["" + tCf + ":" + tCol].timestamp;
              return cb();
            });
          }, function(cb) {
            return putRow(tRow, tCf, tCol, tVal + '1', (++ts).toString(), cb);
          }, function(r, cb) {
            return putRow(tRow, tCf, tCol, tVal + '2', (++ts).toString(), cb);
          }, function(r, cb) {
            var del;
            del = new hbase.Delete(tRow);
            del.deleteFamilyVersion(tCf, ts);
            return client["delete"](testTable, del, function(err, res) {
              assert.notOk(err, "delete returned an error: " + err);
              assert.equal(res.processed, true, "delete wasn't processed");
              return cb();
            });
          }, function(cb) {
            return getRow(tRow, tCf, tCol, tVal + '1', (--ts).toString(), cb);
          }, function(r, cb) {
            var del;
            del = new hbase.Delete(tRow);
            del.deleteFamily(tCf);
            return client["delete"](testTable, del, function(err, res) {
              assert.notOk(err, "delete returned an error: " + err);
              assert.equal(res.processed, true, "delete wasn't processed");
              return cb();
            });
          }, function(cb) {
            return rowDoesNotExist(tRow, cb);
          }
        ];
        return async.waterfall(tests, done);
      });
      it('should delete multiple rows via simple array', function(done) {
        var rows;
        rows = testRows.map(function(row) {
          return row.row;
        });
        return client.mdelete(testTable, rows, function(err, res) {
          assert.notOk(err, "mdelete returned an error: " + err);
          assert.equal(res.length, 0, "mdelete should return empty row");
          return client.mget(testTable, rows, function(err, res) {
            assert.notOk(err, "mget returned an error: " + err);
            assert.equal(res.length, 0, "not all rows were deleted");
            return done();
          });
        });
      });
      return it('should delete multiple rows via array of Delete objects', function(done) {
        var dels, rows;
        rows = testRows.map(function(row) {
          return row.row;
        });
        dels = testRows.map(function(row) {
          return new hbase.Delete(row.row);
        });
        return client.mdelete(testTable, dels, function(err, res) {
          assert.notOk(err, "mdelete returned an error: " + err);
          assert.equal(res.length, 0, "mdelete should return empty row");
          return client.mget(testTable, rows, function(err, res) {
            assert.notOk(err, "mget returned an error: " + err);
            assert.equal(res.length, 0, "not all rows were deleted");
            return done();
          });
        });
      });
    });
    describe('scanner', function() {
      before(function(done) {
        var puts;
        puts = testRows.map(function(row) {
          var put;
          put = new hbase.Put(row.row);
          put.add(row.cf, row.col, row.val);
          return put;
        });
        return client.mput(testTable, puts, done);
      });
      after(function(done) {
        var rows;
        rows = testRows.map(function(row) {
          return row.row;
        });
        return client.mdelete(testTable, rows, done);
      });
      it('should scan the table', function(done) {
        var scan, _i, _ref, _results;
        scan = client.getScanner(testTable);
        return async.eachSeries((function() {
          _results = [];
          for (var _i = 0, _ref = testRows.length; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this), function(i, cb) {
          if (i === testRows.length) {
            return scan.next(function(err, row) {
              assert.notOk(err, "scan.next returned an error: " + err);
              assert.equal(Object.keys(row), 0, "last scan should return empty object");
              return cb();
            });
          } else {
            return scan.next(function(err, row) {
              assert.notOk(err, "scan.next returned an error: " + err);
              assert.equal(row.row, testRows[i].row, "rowKey doesn't match");
              return cb();
            });
          }
        }, done);
      });
      it('should stop scanning after closing the scanner', function(done) {
        var scan;
        scan = client.getScanner(testTable);
        return scan.next(function(err, row) {
          assert.notOk(err, "scan.next returned an error: " + err);
          assert.equal(row.row, tRow, "rowKey doesn't match");
          scan.close();
          scan.close();
          return scan.next(function(err, row) {
            assert.notOk(err, "scan.next returned an error: " + err);
            assert.equal(Object.keys(row), 0, "closed scanner should return empty object");
            return done();
          });
        });
      });
      it('should scan the table with startRow and stopRow', function(done) {
        var scan;
        scan = client.getScanner(testTable, '5', '6');
        return scan.next(function(err, row) {
          assert.notOk(err, "scan.next returned an error: " + err);
          assert.equal(row.row, testRows[1].row, "rowKey doesn't match");
          return scan.next(function(err, row) {
            assert.notOk(err, "scan.next returned an error: " + err);
            assert.equal(Object.keys(row), 0, "should return empty object");
            return done();
          });
        });
      });
      it('should report invalid filter for scan', function(done) {
        var e, scan;
        scan = client.getScanner(testTable);
        try {
          scan.setFilter({
            nonexistingFilter: true
          });
          return done('did not detect invalid filter');
        } catch (_error) {
          e = _error;
          assert.equal(e.message, 'Invalid filter NonexistingFilter', "invalid error message");
          return done();
        }
      });
      it('should scan the table with filter', function(done) {
        var scan;
        scan = client.getScanner(testTable);
        scan.setFilter({
          columnPrefixFilter: {
            prefix: testRows[2].col
          }
        });
        return scan.next(function(err, row) {
          assert.notOk(err, "scan.next returned an error: " + err);
          assert.equal(row.row, testRows[2].row, "rowKey doesn't match");
          assert.equal(row.cols["" + testRows[2].cf + ":" + testRows[2].col].value, testRows[2].val, "value doesn't match");
          return scan.next(function(err, row) {
            assert.notOk(err, "scan.next returned an error: " + err);
            assert.equal(Object.keys(row), 0, "scan.next should return empty object");
            return done();
          });
        });
      });
      it('should scan the table with filterList', function(done) {
        var fl, scan;
        scan = client.getScanner(testTable);
        fl = new hbase.FilterList('MUST_PASS_ONE', {
          columnPrefixFilter: {
            prefix: testRows[2].col
          }
        });
        scan.setFilter(fl);
        return scan.next(function(err, row) {
          assert.notOk(err, "scan.next returned an error: " + err);
          assert.equal(row.row, testRows[2].row, "rowKey doesn't match");
          assert.equal(row.cols["" + testRows[2].cf + ":" + testRows[2].col].value, testRows[2].val, "value doesn't match");
          return scan.next(function(err, row) {
            assert.notOk(err, "scan.next returned an error: " + err);
            assert.equal(Object.keys(row), 0, "scan.next should return empty object");
            return done();
          });
        });
      });
      it('should scan the table and convert result to array', function(done) {
        var scan;
        scan = client.getScanner(testTable);
        return scan.toArray(function(err, res) {
          var i, row;
          assert.notOk(err, "scan.toArray returned an error: " + err);
          for (i in testRows) {
            row = testRows[i];
            assert.equal(res[i].row, testRows[i].row, "rowKey doesn't match");
            assert.equal(res[i].cols["" + testRows[i].cf + ":" + testRows[i].col].value, testRows[i].val, "value doesn't match");
          }
          return done();
        });
      });
      return it('should scan the table with filterList consisting of multiple filterLists', function(done) {
        var f1, f2, fl1, fl2, fl3, scan;
        scan = client.getScanner(testTable);
        f1 = {
          singleColumnValueFilter: {
            columnFamily: 'cf1',
            columnQualifier: 'col2',
            compareOp: 'EQUAL',
            comparator: {
              substringComparator: {
                substr: '2'
              }
            },
            filterIfMissing: true,
            latestVersionOnly: true
          }
        };
        f2 = {
          singleColumnValueFilter: {
            columnFamily: 'cf1',
            columnQualifier: 'col3',
            compareOp: 'EQUAL',
            comparator: {
              substringComparator: {
                substr: '3'
              }
            },
            filterIfMissing: true,
            latestVersionOnly: true
          }
        };
        fl1 = new hbase.FilterList;
        fl2 = new hbase.FilterList;
        fl3 = new hbase.FilterList('MUST_PASS_ONE');
        fl1.addFilter(f1);
        fl2.addFilter(f2);
        fl3.addFilter(fl1);
        fl3.addFilter(fl2);
        scan.setFilter(fl3);
        return scan.toArray(function(err, res) {
          assert.notOk(err, "scan.toArray returned an error: " + err);
          assert.equal(res[0].row, testRows[1].row, "rowKey doesn't match");
          assert.equal(res[0].cols["" + testRows[1].cf + ":" + testRows[1].col].value, testRows[1].val, "value doesn't match");
          assert.equal(res[1].row, testRows[2].row, "rowKey doesn't match");
          assert.equal(res[1].cols["" + testRows[2].cf + ":" + testRows[2].col].value, testRows[2].val, "value doesn't match");
          return done();
        });
      });
    });
    return describe('increment', function() {
      return it('should increment & incrementColumnValue', function(done) {
        var b, inc, tests;
        inc = 4;
        b = new ByteBuffer(8);
        b.writeLong(65);
        b = b.toBuffer();
        tests = [
          function(cb) {
            return putRow(tRow, tCf, tCol, b, cb);
          }, function(r, cb) {
            var increment;
            increment = new hbase.Increment(tRow);
            assert.equal(increment.getRow(), tRow, "rowKey doesn't match");
            increment.add(tCf, tCol, inc);
            return client.increment(testTable, increment, function(err, res) {
              var val;
              assert.notOk(err, "increment returned an error: " + err);
              val = res.result.cell[0].value.toBuffer();
              assert.equal(hbase.utils.bufferCompare(val, b), inc, "value wasn't incremented");
              return cb();
            });
          }, function(cb) {
            return client.incrementColumnValue(testTable, tRow, tCf, tCol, inc, function(err, res) {
              var val;
              assert.notOk(err, "incrementColumnValue returned an error: " + err);
              val = res.result.cell[0].value.toBuffer();
              assert.equal(hbase.utils.bufferCompare(val, b), inc * 2, "value wasn't incremented");
              return cb();
            });
          }, function(cb) {
            return deleteRow(tRow, cb);
          }
        ];
        return async.waterfall(tests, done);
      });
    });
  });

}).call(this);
